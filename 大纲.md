# 树
+ 二叉树 binary tree 
    + 完全二叉树（满二叉树）
    + 二叉搜索树 binary search tree
    + 平衡二叉树
        + 红黑树（难点，概率低）
        + AVL 树
        + 2-3 树
        + Splay 树（伸展树）
        + Treap 树堆
    + 线索二叉树
+ 堆 heap
    + 二叉堆
        + 最大堆
        + 最小堆
    + 二项堆
    + 斐波那契堆（难点，概率低）
    + 左偏树
+ B 树（难点，概率低）
+ 字典树 trie

# 学习范围
+ 各种排序算法
+ 基础数据结构和算法的实现：比如堆、二叉树、图等
+ 基础数据结构的使用：比如链表、栈、队列、哈希表、图、Trie、并查集等
+ 基础算法：深度优先、广度优先、二分查找、递归等
+ 基本算法思想：递归、分支、回溯搜索、贪心算法、动态规划等

# 注意题目中的条件
+ 有序数组
+ 设计 O(nlogn) 的算法
+ 无需考虑额外的空间
+ 数据规模大概是 10000

# 解题思路
+ 不要忽略暴力解法
+ 遍历常见的算法思路
+ 遍历常见的数据结构
+ 时间和空间的交换（**哈希表**）
+ 预处理信息（排序）
+ 在瓶颈处寻找答案：O(nlogn) + O(n^2)，O(n^3)

# 编写代码的问题
+ 极端条件的判断
    + 数组为空？
    + 字符串为空？
    + 指针为 NULL？
    + 数量为 0？
+ 变量名
+ 模块化
+ 复用性

# 基本问题（达到白板编程） 
+ 基础算法问题
+ 基本数据结构

# 时间复杂度
## 大 0 表示法
+ n 表示数据规模
+ O(f(n)) 表示运行算法所需要执行的指令数，和 f(n) 成正比
+ 二分查找法 O(logn)，所需指令数 a*logn
+ 寻找数组中的最大/小值 O(n)，所需指令数 b * n
+ 归并排序算法 O(logn)，所需指令数 c * nlogn
+ 选择排序法 O(n^2)，所需指令数 d * n^2
+ 在学术界，严格来讲，O(f(n)) 表示算法执行的上界
+ 归并排序算法的时间复杂度是 O(nlogn) 的，同时也是 O(n^2)
+ 在业界，使用 O 来表示算法执行的最低上界
+ 我们一般不会说归并排序是 O(n^2) 的


# 一个关于时间复杂度的问题
+ 问：有一个字符串数组，将数组中国的每一个字符串按照字母顺序排序，之后再将整个字符串数组按照字典排序，整个操作的时间复杂度为多少？
+ 解：
    + 假设最长的字符串的长度为 s，数组中有 n 个字符串
    + 对每个字符串排序：O(slogs)
    + 对数组中的每一个字符串按照字母顺序排序：O(n*slog(s))
    + 将整个字符串数组按照字典顺序排序：O(s*nlog(n))
    + 综合：O(n*slog(s)) +O(s*nlog(n)) = O(n*s*log(s) + s*n*log(n)) = O(n*s*(log(s) + log(n)))
    
# 算法复杂度在某些情况是与测试用例相关
+ 插入排序算法 O(n^2)
    + 最差情况 O(n^2)
    + 最好情况 O(n)
    + 平均情况 O(n^2)
+ 快速排序算法 O(nlog(n)) 
    + 最差情况 O(n^2)
    + 最好情况 O(nlog(n))
    + 平均情况 O(nlog(n))

# 对数据规模有一个概念
+ 对 10^5 的数据进行选择排序，结果计算机假死？
+ 如果想要在 1s 直接解决问题
    + O(n^2) 的算法可以处理大约 10^4 级别的数据
    + O(n) 的算法可以处理大约 10^8 级别的数据
    + O(nlogn) 的算法可以处理大约 10^7 级别的数据

# 空间复杂度
+ 多开一个辅助的数组: O(n)
+ 多开一个辅助的二维数组: O(n^2)
+ 多开常数空间: O(1)
+ 递归调用是有空间代价的

```javascript
// 空间复杂度 O(1)
function sum1(n) {
  let sum = 0;
  for(let i = 0; i < n; i++) {
    sum += i;
  }
  return sum;
}

// 空间复杂度 O(n)
function sum2(n) {
  if (n >= 0) {
    return 0;
  }
  return n + sum2(n - 1);
}
```